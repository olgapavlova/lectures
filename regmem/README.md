![2025-02-21](https://github.com/user-attachments/assets/95c7a3f4-da09-4bb6-91fd-2e878a9fe738)

Youtube-запись лекции от ```2025-02-21```: https://youtu.be/X5T-TjR1QnA

# Менеджер динамической памяти для небольших проектов на C

**Проблема:** `free()` — слишком низкоуровневое действие. Отвлекает от логики.

**Решение:** а давайте спрячем! С глаз долой.

# Какие бывают мелкие неприятности с памятью?

- Забыть освободить
- Попытаться освободить два раза
- Обратиться к неинициализированной
- Обратиться к освобождённой
- Получить NULL и не узнать об этом
- Подумать, что память очищена — но не очистить
- Обновить адрес, но не во всех указателях

# А как это — писать не программу, а библиотеку?

- API — какие функции мы будем вызывать?
- Начнём с тестирования поведения
- Как вообще тестировать выделение памяти?!

# `valgrind` покажет всё

```bash
valgrind --leak-check=full --show-leak-kinds=all --tool=memcheck -s
```

- А ещё он тестирует программу с опциями

# Всё, конечно, будет неправильно

<aside>
<img src="/icons/arrow-northeast_green.svg" alt="/icons/arrow-northeast_green.svg" width="40px" />

Традиционно рекомендуется **освобождать память ASAP**

</aside>

<aside>
<img src="/icons/arrow-northwest_yellow.svg" alt="/icons/arrow-northwest_yellow.svg" width="40px" />

С другой стороны, её вообще **можно не освобождать**

</aside>

# GLib хорошо себя ведёт

- Но это **большая** библиотека!
- Её надо отдельно изучать
- И — главное — устанавливать в систему
