![2025-05-16](https://github.com/user-attachments/assets/4c3e9c5a-0331-415f-800e-64cba53c4573)

Youtube-запись от `2025-05-16`: https://youtu.be/ncZitX_5A_k
Код проекта: https://github.com/olgapavlova/oldkeyboard

# Превращаем электричество в данные на микроконтроллере ATmega32u4
## Клавиатура, мы тебя слышим!
![1](https://github.com/user-attachments/assets/a748c637-b96a-4e6c-b8e9-f1badc4b83f3)

- Исследуем руками и глазами, очень грубо
- Первое, что напрашивается — 8 сигналов отправляем + 5 ждём (или наоборот)


**Не допустим разбазаривания ножек!**


- …тем более что бывают ещё и аналоговые ножки (пины)

### Вот на пин пришло напряжение. И?

**Цифра:** 0 или 1, без вариантов

**Аналог:** от 0 до 1023 условных попугаев


Давайте говорить «**пин**»

- Нюансы про снижение количества используемых пинов
    - https://www.rlocman.ru/shem/schematics.html?di=652059&srsltid=AfmBOopJmp5TDlvebGyFJQdb0N5wkWXNhBNA4_OEJe_LIK8ZaNQBzXtr — схема буквально с одним контактом
    - https://easyelectronics.ru/matrichnaya-klaviatura.html — ещё одна клавиатурная схема
    - У ширпотреб-резисторов очень высокая погрешность. Значит, одним контактом на 40 клавиш не обойдётся. Возьмём 4. То есть 10=2x5 клавиш на один контакт. Есть шансы, что погрешность будет невелика.
    
![2](https://github.com/user-attachments/assets/8ed346f2-b58b-4019-84ba-6945af7ab574)

> …короче, мы смогли свести всё к четырём аналоговым пинам
> 

## Сигналы-то пришли, но как их понять?

- Похоже, нас устроят разъёмы `A0`-`A4` на плате
- И они придут на пины `PF7`-`PF4` (в другую сторону, да)
- Какой комплект регистров нам тут поможет?


ADC — аналого-цифровой преобразователь


> Мы медленно забываем о документации и начинаем читать [~~что попало~~](https://www.pulinglobal.com/atmelavrmicrocontrollertutorial/5.-analog-to-digital-converter-(adc)) [всё подряд](http://microelex.blogspot.com/p/2.html) [где угодно](https://www.instructables.com/Introduction-to-ADC-in-AVR-Microcontroller-for-Beg/)
> 

```c
ADCSRA |= 1 << ADEN;  // вообще включить ADC
ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);  // помедленней, я записываю
ADMUX |= 1 << REFS0;  // определить условных попугаев
ADMUX = (ADMUX & 0xF0) | ([номер пина] & 0x0F)// указать на пин (должен остаться только один)
ADCSRA |= (1 << ADSC);  // начать преобразование
while (ADCSRA & (1 << ADSC)); // дождаться окончания преобразования
uint16_t result = ADC;  // получить результат преобразования
```

## Микроконтроллер прочёл — а мы?


Где RX/TX, там и UART

![3](https://github.com/user-attachments/assets/dd45f1a9-f3a8-481a-ad17-1ec35022838a)

- Нюансы настройки этой железки
    
    Чип `FT232RL`.
    
    Джампер замкнуть на 5 вольт.
    
    Соединять с Micro Pro: `GND-GND` и `RX-TX` + `TX-RX`.
    
    Выход VCC никуда не подключать.
    
    `serial` и `minicom` заменят Serial-монитор в Arduino IDE.
    

После подключения опознаётся как `ttyUSB0`:

```bash
ls /dev/ttyUSB*
```

Да, это ещё один провод от контроллера к компьютеру

Теперь отправим что-нибудь через UART.

```c
// настройки скорости — стандарт + формула
#define BAUD 9600
#define MYUBRR F_CPU/16/BAUD-1
...
// установка скорости
UBRR1H = (uint8_t)(MYUBRR >> 8);
UBRR1L = (uint8_t)(MYUBRR & 0xFF);
...
// настройка: 8 бит данных, 1 стоп-бит
UCSR1B = (1 << TXEN1) | (1 << RXEN1);  // Включаем передатчик и приёмник
UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // 8 бит данных
...
while (!(UCSR1A & (1 << UDRE1))); // ждём готовности к передаче
UDR1 = data;  // отправляем байт
```

В `Makefile` всё как обычно, но нужно добавить:

```bash
BAUD = 9600
```

Смотрим, что к нам приходит:

```bash
screen /dev/ttyUSB0 9600
```

Зелёный светодиод — исходящие (от микроконтроллера) данные, красный — входящие.

Нажимаем любые кнопки на клавиатуре — активируется входящий в микроконтроллер поток, горит красный светодиод.

```bash
minicom -D /dev/ttyUSB0 -b 9600
```

Выход — `Ctrl+A` → `K` → `Y`

`Ctrl+A` → `Z` показать все команды

**Внимание!** Позади много архитектурного шлака. Ещё вернёмся.

</aside>
