
![2025-05-30](https://github.com/user-attachments/assets/bdd43b15-e3bf-4436-8a21-63d5f69284c3)

Youtube-запись от `2025-05-30`: https://youtu.be/U1_JgNiSZs8

# USB HID • Реализация через LUFA

## План на сегодня

- [x]  Научиться выдавать микроконтроллер за USB HID устройство
- [x]  Конкретно прикидываться клавиатурой
- [x]  Научиться отправлять данные с МК
- [x]  Видеть «клавиатуру» на стороне Linux
- [x]  Вводить данные с «клавиатуры» в компьютер

### Если повезёт (spoiler: не повезло)

- [ ]  Перехватывать данные с «клавиатуры» в приложение
- [ ]  Написать свой обработчик для такой «клавиатуры»
- [ ]  Реализовать схему «Ты ему слово, он тебе десять»

## Пусть хотя бы заработает

- The Lightweight USB Framework for AVRs
- [Демо-код реализации именно клавиатуры](https://github.com/abcminiuser/lufa/tree/master/Demos/Device/ClassDriver/Keyboard)


Сайта нет, жизни нет, Github [есть](https://github.com/abcminiuser/lufa/tree/master)


### Запускаем

- Используем собственную систему сборки LUFA
- Что изменить в makefile?
    
    ```makefile
    MCU   = atmega32u4
    F_CPU = 16000000
    LUFA_PATH = [тут ваш реальный путь к LUFA]
    ```
    
- Добавляем цель прошивки для нашего удобства:
    
    ```makefile
    DEVICE = /dev/ttyACM0
    DRIVER = avrdude
    ...
    flash: $(TARGET).hex
    	stty -F $(DEVICE) 1200
    	sleep 2
    	$(DRIVER) -v -p $(MCU) -c avr109 -P $(DEVICE) -b 57600 -U flash:w:$<
    ```
    

### Проверяем факт подключения

- `sudo dmesg -w` покажет всё в прямом эфире
- `lsusb` показать все подключённые USB-устройства
    
    `-v` детали про каждое устройство — в том числе дескрипторы
    
    `-t` список устройств в виде дерева
    
- Давайте найдём не просто USB, а устройство ввода:
    
    ```bash
    for i in /sys/class/input/event*/device/name; do
      echo -n "$i: "; cat "$i"
    done
    ```
    
- Или для начала хотя бы `ls /sys/class/input` — все устройства ввода
- Откуда такое богатство? Вспомним, чем занят `/sys`

### Смотрим, чем занято устройство

- `sudo evtest` мониторинг устройств ввода
- `cat /dev/input/event5` just for fun


Пока ничего не происходит


## Меняем что-нибудь и заодно узнаём про внутренности LUFA

### Как настроить фреймворк


**Хотим** менять поведение системы сборки


- Генератор (и вообще система) документации Doxygen
    
    `make doxygen` сгенерить документацию
    
    `doxygen -u` обновить конфигурацию
    
    `doxyfile` → `PAPER_TYPE = a4` исправить ошибку с форматом бумаги
    
- make-файлы в отдельных файлах
    
    `$(LUFA_PATH)/Build/DMBS/DMBS/doxygen.mk` цели и настройки Doxygen
    
- Смотреть лучше через нормальный браузер, не `lynx`
    
    `python3 -m http.server 8080`
    


Задача: сделать `clean` не таким шумным


### Как дописать в болванку свой код


**Хотим**, чтобы он что-нибудь делал


- `Keyboard.c` в принципе `main()` можно прочесть «здравым смыслом» и эрудицией про поведение USB HID
- Нам явно нужен `CALLBACK_HID_Device_CreateHIDReport()`
- А давайте просто уберём условие нажатия кнопки?
- …и увидим, что ничего не работает
- Почему?
    
    Оказывается, кнопку нужно ещё и отпускать
    
- Что-то нажимается, но мы не рады


**Хотим** убрать истерику


- `value 2` признак повторного нажатия
- вводим три состояния
    
    ```mermaid
    flowchart TB
    wait(Ждём)
    pressed(Только что нажали)
    released(Только что отпустили)
    
    wait:::w ==> pressed:::p ==> released:::r ==> wait
    
    classDef p fill:#FE8019;
    classDef r fill:#B8BA46;
    classDef w fill:#FABD2F;
    ```
    
- ставим таймер
    
    
    Так себе таймер, если честно
        


**А ещё:** реагировать на физическую кнопку — посылать разные коды кнопок — нажимать несколько кнопок одновременно — разобраться в остальном коде — …
