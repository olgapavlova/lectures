<img width="1280" height="720" alt="2025-10-31" src="https://github.com/user-attachments/assets/0f208e24-5a69-41a1-a7c0-80c841d6d20e" />

Youtube-запись от `2025-10-31`: https://youtu.be/XaqcEISmLKU

> [!CAUTION]
> Если можно без `malloc()` — нужно без `malloc()`

# Разглядываем динамическую память

> [!TIP]
> А именно — двумерный массив заранее неизвестной длины

```mermaid

flowchart LR

subgraph memory
header([Заголовок]):::red
data([Начало данных]):::green
1((•)):::yellow
2((•)):::yellow
3((•)):::yellow
4((•)):::yellow
header --> data ==> 1 ==> 2 ==> 3 ==> 4
end

pointer([Указатель]):::black -.-> data

classDef green fill:#7c7b00,stroke:#7c7b00,color:#d4c493;
classDef yellow fill:#af7a00,stroke:#af7a00,color:#d4c493;
classDef black fill:#23211b,stroke:#23211b,color:#d4c493;
classDef red fill:#be440b,stroke:#be440b,color:#d4c493;

```

> [!CAUTION]
> Заголовок — что за зверь?

> [!TIP]
> Начало данных и указатель — кое-что знаем

>  `free()` откуда-то знает, **сколько** памяти освобождать

## Сначала смотрим с помощью C
`malloc_usable_size(p)` — единственный законный способ (да и то нужен `#define _GNU_SOURCE`)

Прогулки с помощью `(size_t*)p - 2` — OK, но сомнительны:
- первый байт — размер предыдущего блока
- второй байт — сырая память и флаги
	- флаги по маскам: `0x1`, `0x2`, `0x4` — очень экзотичны
	- реальная память — по маске `~(0x7)` (кратна восьми!)

## Теперь `gdb`
#### Общая идея
1. Выделяем память.
2. Заполняем «видимыми» значениями.
3. Следим, правильно ли идёт заполнение.
#### Шпаргалка по `gdb`
`l` вывести код программы

`b N` поставить точку останова

`watch` отследить переменную

`info b` показать все точки и отслеживаемые переменные

`n` выполнить следующую строку

`c` выполнить до следующей точки останова

`r arg1 arg2` запустить программу с аргументами

`x/30gx address` показать содержимое памяти (формат, сколько, размер блока)

`p` вывести значение

